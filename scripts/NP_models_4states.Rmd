---
title: "Tesi_AbsDelay_S5_versione2_NuoveZone"
output: html_document
date: "2024-11-26"
---

TENTATIVO 3.1:
STATE DEFINITION:
0) OnTime: Arrival Delay <= 5min
1) Delay: 5min < Arrival Delay <= 10min
2) Medium Delay: 10min < Arrival Delay <= 15min
3) Severe Delay: Arrival Delay > 15min

NB: in questo file riporto una diversa def per le zone della tratta (quindi qui guarda solo quello, il resto prendilo dal file che c'è in 27/02/2025):
    A) DIREZIONE 0:
       - PreMi1: da Varese a Gallarate;
       - PreMi2: da Busto Arsizio a Rho Fiera;
       - Mi: da Milano Certosa a Milano Forlanini;
       - PostMi da Segrate a Treviglio.
    B)  DIREZIONE 1:
       - PreMi: da Treviglio a Segrate;
       - Mi da Milano Forlanini a Milano Certosa;
       - PostMi1: da Rho Fiera a Busto Arsizio;
       - PostMi2: da Gallarate a Varese.
       
Aggiunte rispetto alla versione dell'incontro del 12/3:
- considero tre mesi al posto di uno solo (settembre, ottobre, novembre)
- rifaccio tutte le analisi sul nuovo dataset (qui trivi solo le nuove zone della tratta)
- modello frailty e cox sistemati


# Libraries and Dataset --------------------------------------------------------
```{r}
setwd("C:/Users/Utente/Desktop/Tesi/Dati_Milano-Varese")

# Loading necessary libraries
library(survival)
library(survminer)
library(dplyr) 
library(ggplot2)
library(knitr)
library(broom)
library(tidyr)
library(mstate)
library(msm)
library(timechange)
library(lubridate)
library("colorspace")
library(frailtypack)
library(gridExtra)
library(survidm)
library(flexsurv)
library(muhaz)
library(gridExtra)


# data=read.csv("C:/Users/Utente/Desktop/Tesi/Dati_Milano-Varese/data.csv")
# data$data=as.Date(data$data, format = "%d/%m/%Y")
# data$partenza=as.POSIXct(data$partenza, format = "%d/%m/%Y %H:%M:%S")
# data$arrivo=as.POSIXct(data$arrivo, format = "%d/%m/%Y %H:%M:%S")
# data$ora_ingresso=as.POSIXct(data$ora_ingresso, format = "%d/%m/%Y %H:%M:%S")
# data$ora_uscita=as.POSIXct(data$ora_uscita, format = "%d/%m/%Y %H:%M:%S")
# str(data)
# # View(data)
```




# Linea Varese-Treviglio (S5) ----


## Preprocessing ----

Inizio considerando solo la linea S5
```{r}
data_S5=data[which(data$linea == "S5"),]
#View(data_S5)
dim(data_S5) #734718     29
str(data_S5)
#summary(data)
sum(is.na(data_S5)) #0
```

FERMATE: controllo che non ci siano fermate straordinarie sia tra le fermate intermedie, sia tra quelle di origine/destinazione. NB: più avanti creerai due dataset diversi per direzione 0: da Varese a Treviglio e direzione 1: da Treviglio a Varese.
```{r}
## Considero SOLO le fermate da programmazione usuale:
unique(data_S5$nome)
# Tratta intera (usuale):
# - Varese
# - Gazzada
# - Castronno
# - Albizzate
# - Cavaria
# - Gallarate
# - Busto
# - Legnano
# - Canegrate
# - Parabiago
# - Vanzago
# - Rho
# - Rho Fiera
# - Mi Certosa
# - Mi VIllapizzone
# - Mi Lancetti
# - Mi P. Garibaldi
# - Mi Repubblica
# - Mi P. Venezia
# - Mi Dateo
# - Mi P. Vittoria
# - Mi Forlanini
# - Segrate
# - Pioltello
# - Vignate
# - Melzo
# - Pozzuolo Martesana
# - Trecella
# - Cassano D'Adda
# - Treviglio

Station_list=c("VARESE", "GAZZADA SCHIANNO MORAZZONE", "CASTRONNO", "ALBIZZATE SOLBIATE ARNO", "CAVARIA OGGIONA IERAGO" , "GALLARATE", "BUSTO ARSIZIO", "LEGNANO", "CANEGRATE", "PARABIAGO", "VANZAGO POGLIANO", "RHO", "RHO FIERA", "MILANO CERTOSA", "MILANO VILLAPIZZONE", "MILANO LANCETTI", "MILANO PORTA GARIBALDI SOTTERRANEA", "MILANO REPUBBLICA", "MILANO PORTA VENEZIA", "MILANO DATEO", "MILANO PORTA VITTORIA", "MILANO FORLANINI", "SEGRATE", "PIOLTELLO LIMITO", "VIGNATE", "MELZO", "POZZUOLO MARTESANA", "TRECELLA", "CASSANO D'ADDA", "TREVIGLIO")
data_S5=data_S5[data_S5$nome %in% Station_list,]
dim(data_S5) #734715     29


## Considero SOLO le partenze e gli arrivi coincidenti coi capolinea:
unique(data_S5$nome_o)
unique(data_S5$nome_d)
Capolinea=c("TREVIGLIO", "VARESE")
data_S5=data_S5[data_S5$nome_o %in% Capolinea & data_S5$nome_d %in% Capolinea,]
dim(data_S5) #651197     29
```


TEMPO: considero solo i giorni feriali e tengo solo le osservazioni per Ottobre e Marzo. NB: più avanti dividerai i due dataset precedenti in altri due dataset uno per Ottobre e uno per Marzo.
```{r}
## Considero SOLO i giorni feriali:
days_week=c(0:4)
data_S5=data_S5[data_S5$dow %in% days_week,]
dim(data_S5) #453680     29


## Considero SOLO settembre, ottobre e novembre:
month=c("09", "10", "11")
data_S5=data_S5[format(data_S5$data, "%m") %in% month, ]
dim(data_S5) #115740     29


##Elimino i giorni di festa:
# 1 Gennaio – Capodanno – domenica
# 6 Gennaio – Epifania – venerdì
# 9 Aprile – Pasqua – domenica
# 10 Aprile – Lunedì dell’Angelo o di Pasquetta – lunedì
# 25 aprile – Festa della liberazione – martedì
# 1 maggio – Festa dei lavoratori – lunedì
# 2 giugno – Festa della Repubblica – venerdì
# 15 agosto – Ferragosto – martedì
# 1 novembre – Tutti i santi – mercoledì
# 8 dicembre – Festa dell’Immacolata Concezione – venerdì
# 25 dicembre – Natale – lunedì
# 26 dicembre – Santo Stefano – martedì
holidays=as.Date(c("2023-01-01", "2023-01-06", "2023-04-09", "2023-04-10", "2023-04-25", "2023-05-01", "2023-06-02", "2023-08-15", "2023-11-01", "2023-12-08", "2023-12-25", "2023-12-26"))
data_S5=data_S5[!data_S5$data %in% holidays, ]
dim(data_S5) #115740     29
```


RITARDI: Di seguito riportati anche istogrammi e boxplot dei ritardi in uscita e ritardi in ingresso.
```{r}
data_S5<- data_S5[data_S5$ritardo_ingresso >= -1200 & data_S5$ritardo_ingresso <= 2400, ]
data_S5<- data_S5[data_S5$ritardo_uscita >= 0 & data_S5$ritardo_uscita <= 2400, ]
min(data_S5$ritardo_ingresso) #-1200-->-20min
max(data_S5$ritardo_ingresso) #2400-->40min
min(data_S5$ritardo_uscita) #0min
max(data_S5$ritardo_uscita) #2400-->40min

# write.csv(data_S5, file = "data_S5.csv", row.names = FALSE)
# data_S5=read.csv("C:/Users/Utente/Desktop/Tesi/Dati_Milano-Varese/data_S5.csv")
# data_S5$data=as.Date(data_S5$data, format = "%Y-%m-%d")
# data_S5$partenza=as.POSIXct(data_S5$partenza, format = "%Y-%m-%d %H:%M:%S")
# data_S5$arrivo=as.POSIXct(data_S5$arrivo, format = "%Y-%m-%d %H:%M:%S")
# data_S5$ora_ingresso=as.POSIXct(data_S5$ora_ingresso, format = "%Y-%m-%d %H:%M:%S")
# data_S5$ora_uscita=as.POSIXct(data_S5$ora_uscita, format = "%Y-%m-%d %H:%M:%S")
data_S5 = data_S5[order(data_S5$partenza, data_S5$ora_ingresso), ] #riordina le tratte in ordine cronologico
row.names(data_S5) <- NULL #cambia gli indici adattandoli allo step precedente
#View(data_S5)


## Ritardo_ingresso (hist):
bin_width=50 
breaks=seq(from = floor(min(data_S5$ritardo_ingresso)/bin_width) * bin_width - bin_width/2, to = ceiling(max(data_S5$ritardo_ingresso)/bin_width) * bin_width + bin_width/2, by = bin_width)
hist(data_S5$ritardo_ingresso, probability = TRUE, col = "#EB5C82", 
     main ="Histogram of Arrival Delays for Line S5 after preprocessing", 
     xlab = "Delay (Sec)", ylab = "Density", breaks = breaks)


## Ritardo_uscita (hist):
bin_width=50 
breaks=seq(from = floor(min(data_S5$ritardo_uscita)/bin_width) * bin_width - bin_width/2, to = ceiling(max(data_S5$ritardo_uscita)/bin_width) * bin_width + bin_width/2, by = bin_width)
hist(data_S5$ritardo_uscita, probability = TRUE, col = "#87CEFA", 
     main ="Histogram of Departure Delays for Line S5 after preprocessing", 
     xlab = "Delay (Sec)", ylab = "Density", breaks = breaks)


##Ritardo_ingresso & Ritardo_uscita (boxplot):
combined_data=list(Arrival_Delays = data_S5$ritardo_ingresso, Departure_Delays = data_S5$ritardo_uscita)
boxplot(combined_data, col = c("#EB5C82", "#87CEFA"), main = "Boxplot of Arrival and Departure Delays for Line S5", 
        ylab = "Delay (Sec)", names = c("Arrival Delays", "Departure Delays"))


# write.csv(data_S5, file = "data_S5.csv", row.names = FALSE)
```

ORARI E DIREZIONI: Cerca quali sono gli orari possibili e come si dividono sulla base delle due direzioni di percorrenza (da Varese a Treviglio e viceversa).
```{r}
# data_S5=read.csv("C:/Users/Utente/Desktop/Tesi/Dati_Milano-Varese/data_S5.csv")
# data_S5$data=as.Date(data_S5$data, format = "%Y-%m-%d")
# data_S5$partenza=as.POSIXct(data_S5$partenza, format = "%Y-%m-%d %H:%M:%S")
# data_S5$arrivo=as.POSIXct(data_S5$arrivo, format = "%Y-%m-%d %H:%M:%S")
# data_S5$ora_ingresso=as.POSIXct(data_S5$ora_ingresso, format = "%Y-%m-%d %H:%M:%S")
# data_S5$ora_uscita=as.POSIXct(data_S5$ora_uscita, format = "%Y-%m-%d %H:%M:%S")
# data_S5 = data_S5[order(data_S5$partenza, data_S5$ora_ingresso), ] #riordina le tratte in ordine cronologico
# row.names(data_S5) <- NULL #cambia gli indici adattandoli allo step precedente
#View(data_S5)


#Identifica i treni nell'arco di una giornata:
hours_partenza=format(data_S5$partenza, "%H:%M")
unique_hours_partenza=sort(unique(hours_partenza))
unique_hours_partenza
# "05:13" "05:40" "05:43" "06:10" "06:13" "06:40" "06:43" "07:10" "07:13" "07:40" "07:43" "08:10" "08:13" "08:40" "08:43" "09:10" "09:13" "09:40" "09:43" "10:10" "10:13" "10:40" "10:43" "11:10" "11:13" "11:40" "11:43" "12:10" "12:13" "12:40" "12:43" "13:10" "13:13" "13:40" "13:43" "14:10" "14:13" "14:40" "14:43" "15:10" "15:13" "15:40" "15:43" "16:10" "16:13" "16:40" "16:43" "17:10" "17:13" "17:40" "17:43" "18:10" "18:13" "18:40" "18:43" "19:10" "19:13" "19:40" "19:43" "20:10" "20:13" "20:40" "20:43" "21:10" "21:40" "21:43"
length(unique_hours_partenza) #64


#Quali sono le direzioni di percorrenza per ogni orario?
stazioni_uniche=c()
for (hour in 1:length(unique_hours_partenza)) {
  origine=data_S5$nome_o[format(data_S5$partenza, "%H:%M") == unique_hours_partenza[hour]]
  stazioni_uniche=c(stazioni_uniche, ifelse(length(origine) > 0, origine[1], "Nessuna stazione"))
}
risultato=table(Ora = unique_hours_partenza, Stazione = stazioni_uniche)
print(risultato)
```


TRAFFICO ORARIO: Vado a definire 3 fasce orarie di riferimento per studiare meglio il fenomeno dei ritardi. 
1) Peak-time del mattino: 6-10
2) Periodo intermedio: 10-16
3) Peak-time della sera: 16-20
```{r}
#Indicatore per traffico ferroviario orario:
data_S5$partenza_temp=format(data_S5$partenza, "%H:%M")
data_S5$partenza_temp=as.POSIXct(data_S5$partenza_temp, format="%H:%M")
soglia1=as.POSIXct("06:00", format="%H:%M")
soglia2=as.POSIXct("10:00", format="%H:%M")
soglia3=as.POSIXct("16:00", format="%H:%M")
soglia4=as.POSIXct("20:00", format="%H:%M")
data_S5$traffico_ora=as.numeric(NA)
for (i in 1:nrow(data_S5)) {
  if(data_S5$partenza_temp[i] >= soglia1 & data_S5$partenza_temp[i] < soglia2)
    data_S5$traffico_ora[i]='Morning-Peak Time'
  else if(data_S5$partenza_temp[i] >= soglia2 & data_S5$partenza_temp[i] < soglia3)
    data_S5$traffico_ora[i]='Off-Peak Time'
  else if(data_S5$partenza_temp[i] >= soglia3 & data_S5$partenza_temp[i] < soglia4)
    data_S5$traffico_ora[i]='Evening-Peak Time'
}
data_S5<-na.omit(data_S5)
any(is.na(data_S5))
unique(data_S5$traffico_ora) #"Morning-Peak Time"  "Off-Peak Time"  "Evening-Peak Time"
```


DIREZIONE: Categorizzo le due possibili direzioni di percorrenza della tratta.
0: da Varese a Treviglio
1: da Treviglio a Varese
```{r}
#Indicatore direzione della tratta:
data_S5$direzione=ifelse(data_S5$nome_o=='VARESE', 0, 1)
unique(data_S5$direzione) #1 0
```


ZONA: Categorizzo le 4 possibili zone della tratta:
- Zona 1: Varese - Gallarate;
- Zona 2: Busto A. - Rho Fiera;
- Zona 3: Mi Certosa - Mi Forlanini;
- Zona 4: Segrate - Treviglio.
```{r}
#Indicatore zona tratta:
data_S5$zona=as.numeric(NA)

#Identifico le stazioni appartenenti alle 3 diverse zone:
Varese1<- c("VARESE", "GAZZADA SCHIANNO MORAZZONE", "CASTRONNO", "ALBIZZATE SOLBIATE ARNO", "CAVARIA OGGIONA IERAGO" , "GALLARATE")
Varese2<- c("BUSTO ARSIZIO", "LEGNANO", "CANEGRATE", "PARABIAGO", "VANZAGO POGLIANO", "RHO", "RHO FIERA")
Milano <- c("MILANO CERTOSA", "MILANO VILLAPIZZONE", "MILANO LANCETTI", "MILANO PORTA GARIBALDI SOTTERRANEA", "MILANO REPUBBLICA", "MILANO PORTA VENEZIA", "MILANO DATEO", "MILANO PORTA VITTORIA", "MILANO FORLANINI")
Treviglio<- c("SEGRATE", "PIOLTELLO LIMITO", "VIGNATE", "MELZO", "POZZUOLO MARTESANA", "TRECELLA", "CASSANO D'ADDA", "TREVIGLIO")

for (i in 1:nrow(data_S5)) {
  if(data_S5$nome[i] %in% Milano)
      data_S5$zona[i]<-'Mi-Città'
  else if(data_S5$direzione[i]==0 & is.na(data_S5$zona[i])){
    if(data_S5$nome[i] %in% Varese1)
      data_S5$zona[i]<-'Pre-Mi.1'
    else if(data_S5$nome[i] %in% Varese2)
      data_S5$zona[i]<-'Pre-Mi.2'
    else if(data_S5$nome[i] %in% Treviglio)
      data_S5$zona[i]<-'Post-Mi'
  }
  else if(data_S5$direzione[i]==1 & is.na(data_S5$zona[i])){
    if(data_S5$nome[i] %in% Treviglio)
      data_S5$zona[i]<-'Pre-Mi'
    else if(data_S5$nome[i] %in% Varese2)
      data_S5$zona[i]<-'Post-Mi.1'
    else if(data_S5$nome[i] %in% Varese1)
      data_S5$zona[i]<-'Post-Mi.2'
  }
}
unique(data_S5$zona) #"Pre-Mi"  "Mi-Città"  "Post-Mi.1"  "Post-Mi.2"  "Pre-Mi.1"  "Pre-Mi.2"  "Post-Mi" 
```


ID_Mezzo: Definisco un indentificativo unico per ogni singolo mezzo. NB: dovrai riaggiornarlo in seguito, dopo che avrai spezzettato nei mini datasets.
```{r}
#Inserisci un ID per ogni singolo mezzo (max(ID_Mezzo)=2432):
data_S5 = data_S5 %>%
  mutate(orario_partenza = format(partenza, "%H:%M:%S"),
         giorno_partenza = format(partenza, "%Y-%m-%d")) %>%
  group_by(giorno_partenza, orario_partenza) %>% 
  mutate(ID_Mezzo = cur_group_id()) %>%  
  ungroup()
```


ID_Treno: Definisco un indentificativo unico per ogni orario (tra quelli selezionati nelle 3 sezioni definite sopra). NB: dovrai riaggiornarlo in seguito, dopo che avrai spezzettato nei mini datasets.
```{r}
#Inserisci un ID per ogni treno (treni in giorni diversi, ma con lo stesso orario hanno lo stesso id, quindi max(ID_treno)=56):
data_S5 = data_S5 %>%
  mutate(orario_partenza = format(partenza, "%H:%M:%S")) %>%
  group_by(orario_partenza) %>%
  mutate(ID_Treno = cur_group_id()) %>%  
  ungroup()
```


STATO: Crea una colonna apposita che definisce lo stato del treno sulla base dell'orario di arrivo in stazione (NB: per le stazioni di origine guarda il ritardo nella partenza).
Stato 1: ORARIO: Ritardo <= 5min
Stato 2: RITARDO: 5min < Ritardo <= 15 min
Stato 3: RITARDO GRAVE: Ritardo > 15min
```{r}
#Qual è in media il tempo di percorrenza della tratta?
tempo_percorrenza<- data_S5$arrivo[1] - data_S5$partenza[1]
tempo_percorrenza #Time difference of 2.116667 hours


#Qual è il tempo di ritardo massimo?
rit_max=max(data_S5$ritardo_ingresso)
rit_max #2400s-->40min


data_S5 = data_S5[order(data_S5$partenza, data_S5$ora_ingresso), ] #riordina le tratte in ordine cronologico
row.names(data_S5) <- NULL #cambia gli indici adattandoli allo step precedente
#View(data_S5)

#Rimuovo le fermate soppresse:
data_S5 <- data_S5[data_S5$fermata_soppressa!="true", ]


#Definisco lo stato ritardo grave
data_S5$status=NA
data_S5$status<-as.character(data_S5$status)
unique_ids <- unique(data_S5$ID_Mezzo)
for (id in unique(data_S5$ID_Mezzo)) {
  subset_data <- data_S5[data_S5$ID_Mezzo == id, ]
  for (i in 1:nrow(subset_data)) {
    # Caso 1: ora_ingresso valido e ritardo_ingresso > 900
    if (is.na(subset_data$status[i]) && subset_data$ora_ingresso[i] != as.POSIXct("1970-01-01 01:00:00")) {
      if (subset_data$ritardo_ingresso[i] > 900) {
        subset_data$status[i] <- "SevereDelay"
      }
    }
    # Caso 2: ora_ingresso mancante e ritardo_uscita > 900
    else if (is.na(subset_data$status[i]) && subset_data$ora_ingresso[i] == as.POSIXct("1970-01-01 01:00:00")) {
      if (subset_data$ritardo_uscita[i] > 900) {
        subset_data$status[i] <- "SevereDelay"
      }
    }
  }
  data_S5[data_S5$ID_Mezzo == id, ] <- subset_data
}
unique(data_S5$status) #NA           "SevereDelay"


#Definisco gli stati Orario e Ritardo
for (i in 1:nrow(data_S5)) {
  if (is.na(data_S5$status[i])) { # Controlla solo i casi con status NA
    if (data_S5$ora_ingresso[i] != as.POSIXct("1970-01-01 01:00:00")) {
      if (data_S5$ritardo_ingresso[i] > 600) {
        data_S5$status[i] <- "MediumDelay"
      } 
      else if (data_S5$ritardo_ingresso[i] > 300){
        data_S5$status[i] <- "Delay"
      }
      else data_S5$status[i] <- "OnTime"
      
    } else if (data_S5$ora_ingresso[i] == as.POSIXct("1970-01-01 01:00:00")) {
        if (data_S5$ritardo_uscita[i] > 600) {
          data_S5$status[i] <- "MediumDelay"
        } 
        else if (data_S5$ritardo_uscita[i] > 300){
          data_S5$status[i] <- "Delay"
        }
        else data_S5$status[i] <- "OnTime"
      }
    }
}
unique(data_S5$status) #"OnTime"  "Delay"  "MediumDelay"  "SevereDelay"


data_S5 = data_S5[order(data_S5$partenza, data_S5$ora_ingresso), ] #riordina le tratte in ordine cronologico
row.names(data_S5) <- NULL #cambia gli indici adattandoli allo step precedente
#View(data_S5)


freq_table <- table(data_S5$status)
print(freq_table)
      # Delay MediumDelay      OnTime SevereDelay 
      # 19118        6361       67124        4845  


#write.csv(data_S5, file = "data_S5_versione2.csv", row.names = FALSE)
```


TIME: Istante di ingresso nello stato corrente. Per la prima stazione è 0 e si riferisce alla partenza. NB: è importantissimo controllare poi di avere sempre valori di tempo positivi anche perchè sarebbe assurdo il contrario.
```{r}
# data_S5=read.csv("C:/Users/Utente/Desktop/Tesi/Dati_Milano-Varese/data_S5.csv")
# data_S5$data=as.Date(data_S5$data, format = "%Y-%m-%d")
# data_S5$partenza=as.POSIXct(data_S5$partenza, format = "%Y-%m-%d %H:%M:%S")
# data_S5$arrivo=as.POSIXct(data_S5$arrivo, format = "%Y-%m-%d %H:%M:%S")
# data_S5$ora_ingresso=as.POSIXct(data_S5$ora_ingresso, format = "%Y-%m-%d %H:%M:%S")
# data_S5$ora_uscita=as.POSIXct(data_S5$ora_uscita, format = "%Y-%m-%d %H:%M:%S")
# data_S5 = data_S5[order(data_S5$partenza, data_S5$ora_ingresso), ] #riordina le tratte in ordine cronologico
# row.names(data_S5) <- NULL #cambia gli indici adattandoli allo step precedente
# View(data_S5)


#Aggiungo la colonna time ed eseguo controlli vari:
data_S5 <- data_S5 %>%
  group_by(ID_Mezzo) %>%
  mutate(
    start_ref = partenza[1] + seconds(ritardo_uscita[1]),
    time = as.numeric(difftime(ora_ingresso + seconds(ritardo_ingresso), start_ref, units = "secs")),
    time = ifelse(row_number() == 1, 0, time)  # Imposta time = 0 per la prima riga di ogni gruppo
  ) %>%
  ungroup()
any(data_S5$time<0) #TRUE
data_S5[data_S5$time<0,] 

#Controlla che i tempi siano tutti positivi e rimuovi le righe fallate:
id_torem <- c()
for (i in 1:nrow(data_S5)) {
  if (data_S5$time[i] < 0) {
    id_torem <- c(id_torem, data_S5$ID_Mezzo[i])
  }
}
data_S5 <- data_S5[!data_S5$ID_Mezzo %in% id_torem, ]
data_S5 = data_S5[order(data_S5$partenza, data_S5$ora_ingresso), ]
row.names(data_S5) <- NULL
dim(data_S5)
#97298    40

#Controlla che i tempi di ogni ID_Mezzo siano tutti in ordine crescente:
check_order <- data_S5 %>%
  group_by(ID_Mezzo) %>%
  summarise(is_ordered = all(diff(time) >= 0)) %>%
  ungroup()
check_order %>% filter(!is_ordered)

#Rimuovo ID_Mezzo che non seguono ordine crescente:
ids_to_remove <- data_S5 %>%
  group_by(ID_Mezzo) %>%
  summarise(is_ordered = all(diff(time) >= 0)) %>%
  filter(!is_ordered) %>%
  pull(ID_Mezzo)
data_S5 <- data_S5 %>%
  filter(!ID_Mezzo %in% ids_to_remove)
dim(data_S5)
#86460    40


str(data_S5)
data_S5$direzione=as.factor(data_S5$direzione)
data_S5$traffico_ora=as.factor(data_S5$traffico_ora)
data_S5$status=as.factor(data_S5$status)
data_S5$zona=as.factor(data_S5$zona)


freq_table <- table(data_S5$status)
print(freq_table)
      # Delay MediumDelay      OnTime SevereDelay 
      # 16052        5102       61540        3766 


#Salva dataset:
#write.csv(data_S5, file = "data_S5_versione2.csv", row.names = FALSE)
```





MSDATA: Adesso costruisco un oggetto di tipo 'msdata' per poter utilizzare mstate in combinazione con surivival e flexsurv. Dal momento che la mia matrice di riferimento è circolare e reversibile, uso una funzione diversa da msprep, ma che esegue la stessa operazione senza avere problemi con matrici così definite.
```{r}
# data_S5 <- read.csv("C:/Users/Utente/Desktop/Tesi/Dati_Milano-Varese/data_S5.csv")
# data_S5$data=as.Date(data_S5$data, format = "%Y-%m-%d")
# data_S5$partenza=as.POSIXct(data_S5$partenza, format = "%Y-%m-%d %H:%M:%S")
# data_S5$arrivo=as.POSIXct(data_S5$arrivo, format = "%Y-%m-%d %H:%M:%S")
# data_S5$ora_ingresso=as.POSIXct(data_S5$ora_ingresso, format = "%Y-%m-%d %H:%M:%S")
# data_S5$ora_uscita=as.POSIXct(data_S5$ora_uscita, format = "%Y-%m-%d %H:%M:%S")
# data_S5 = data_S5[order(data_S5$partenza, data_S5$ora_ingresso), ] #riordina le tratte in ordine cronologico
row.names(data_S5) <- NULL #cambia gli indici adattandoli allo step precedente
# View(data_S5)


#Prima di tutto riporto il codice di msprep2 da git:
get_sink_states <- function(tmat) {
  # Identifica le righe della matrice tmat che contengono solo NA
  sink_states <- which(apply(tmat, 1, function(row) all(is.na(row))))
  return(sink_states)
}
msprep2 <- function(entry, tmat, censors=NULL,
                    start_times=NULL, start_states=NULL, covars=NULL,
                    idcol='id') {

    DEFAULT_START_TIME <- 0
    DEFAULT_START_STATE <- 1

    # R CMD CHECK
    id <- NULL
    Tstop <- NULL
    Tstart <- NULL
    state <- NULL
    prev_state <- NULL
    start_state <- NULL
    start_time <- NULL
    time <- NULL
    status <- NULL
    from <- NULL
    to <- NULL
    to.actual <- NULL
    to.possible <- NULL
    trans <- NULL
    censor_time <- NULL

    if (!idcol %in% colnames(entry))
        stop(paste0("Error: id field '", idcol, "' not found in entry."))
    if (!'time' %in% colnames(entry))
        stop("Error: column 'time' not found in entry.")
    if (!'state' %in% colnames(entry))
        stop("Error: column 'state' not found in entry.")

    entry <- entry %>%
                dplyr::rename(id = idcol, Tstop=time)
    # Build up list of unique_ids
    unique_ids <- unique(entry$id)
    nstates <- ncol(tmat)
    state_names <- colnames(tmat)

    if (!is.null(censors)) {
        censors <- censors %>%
                    dplyr::rename(id = idcol)
        unique_ids <- union(unique_ids, unique(censors$id))
    }
    if (!is.null(start_times)) {
        if (!idcol %in% colnames(start_times))
            stop(paste0("Error: id field '", idcol, "' not found in start_times."))
        if (!'start_time' %in% colnames(start_times))
            stop(paste0("Error: column start_time not found in start_times."))
        start_times <- start_times %>%
                    dplyr::rename(id = idcol)
        unique_ids <- union(unique_ids, unique(start_times$id))
    }
    if (!is.null(start_states)) {
        if (!idcol %in% colnames(start_states))
            stop(paste0("Error: id field '", idcol, "' not found in start_states."))
        if (!'start_state' %in% colnames(start_states))
            stop(paste0("Error: column start_state not found in start_states."))

        ss <- start_states$start_state
        if (is.factor(ss)) {
            ss <- as.character(ss)
            start_states$start_state <- as.character(start_states$start_state)
        }

        if (!(is.numeric(ss) || is.character(ss)))
            stop("Error: start_state column must be state name or number.")
        if (is.numeric(ss)) {
            if (!all((ss %% 1) == 0))
                stop("Error: start_state column must be state name or number.")
            if (max(ss) > nstates || min(ss) < 1)
                stop("Error: start_state column must be state name or number.")
        }
        if (is.character(ss)) {
            if (!all(ss %in% state_names))
                stop("Error: start_state column must be state name or number.")
        }

        start_states <- start_states %>%
                    dplyr::rename(id = idcol)
        unique_ids <- union(unique_ids, unique(start_states$id))
    }
    if (!is.null(covars)) {
        if (!idcol %in% colnames(covars))
            stop(paste0("Error: id field '", idcol, "' not found in covars."))
        covars <- covars %>%
                    dplyr::rename(id = idcol)
        unique_ids <- union(unique_ids, unique(covars$id))
    }

    if (is.null(start_states))
        start_states <- data.frame(id=unique_ids, start_state=DEFAULT_START_STATE)
    if (is.null(start_times))
        start_times <- data.frame(id=unique_ids, start_time=DEFAULT_START_TIME)

    # Guards
    # Check that every individual has unique time
    has_dups <- entry %>%
        dplyr::group_by(id) %>%
        dplyr::summarise(has_duplicate_times=sum(duplicated(Tstop))>0)
    if (sum(has_dups$has_duplicate_times) > 0) {
        stop("Error: each id in entry must have unique state entry times.")
    }

    # Convert state names to numbers
    if (is.character(entry$state) || is.factor(entry$state))
        entry$state <- match(entry$state, state_names)
    if (is.character(start_states$start_state) || is.factor(start_states$start_state))
        start_states$start_state <- match(start_states$start_state, state_names)

    ntrans <- sum(!is.na(tmat))
    ninds <- length(unique_ids)

    # Now need to add starting state and times.
    # Firstly, obtain the rank order of each state entry
    entry2 <- entry %>%
        dplyr::group_by(id) %>%
        dplyr::mutate(entry_order = dplyr::row_number(Tstop)) %>%
        dplyr::mutate(prev_state = dplyr::lag(state)) %>%
        dplyr::left_join(start_states, by='id') %>%
        dplyr::mutate(start_state = ifelse(is.na(start_state), DEFAULT_START_STATE, start_state),
                      prev_state = ifelse(is.na(prev_state), start_state, prev_state)) %>%
        dplyr::select(-start_state)

    # Likewise, obtain previous times
    entry3 <- entry2 %>%
        dplyr::mutate(Tstart = dplyr::lag(Tstop)) %>%
        dplyr::left_join(start_times, by='id') %>%
        dplyr::mutate(start_time = ifelse(is.na(start_time), DEFAULT_START_TIME, start_time),
                      Tstart = ifelse(is.na(Tstart), start_time, Tstart)) %>%
        dplyr::select(-start_time) %>%
        dplyr::ungroup() %>%
        dplyr::mutate(time = Tstop - Tstart, status=1) %>%
        dplyr::select(id, from=prev_state, to=state, Tstart, Tstop, time, status)

    # Now need to add the transitions that werent made
    # Need DF of all possible ids and transitions
    sink_states <- match(get_sink_states(tmat), state_names)
    trans_ids <- tmat[!is.na(tmat)]

    tmat_long <- dplyr::bind_rows(lapply(stats::setNames(trans_ids, trans_ids), function(transition) {
        index <- which(tmat == transition) - 1  # Easier to do column/row index arithmetic in zero base
        from <- (index %% nstates) + 1          # Convert back to 1-index
        to <- floor(index / nstates) + 1        # Ditto
        data.frame(from, to)
    }), .id='trans')

    tmat_withids <- cbind(tmat_long[rep(1:nrow(tmat_long), ninds), ],
                          id=rep(unique_ids, each=ntrans))

    # Now join this onto main entry to get possible 'to' states
    entry4 <- entry3 %>%
        dplyr::left_join(tmat_withids, by=c('id', 'from'), suffix=c('.actual', '.possible')) %>%
        dplyr::mutate(status = ifelse(to.actual == to.possible, status, 0)) %>%
        dplyr::select(id, from, to=to.possible, trans, Tstart, Tstop, time, status)   # Clean up

    if (!is.null(censors)) {
        # Two types of people who have useful censor information.
        #   1. Those who never entered any state
        #   2. Those who haven't entered a sink state yet.
        # Can only handle these cases if have their time of last follow up!

        # Identify those who never entered any state
        never_entered_state <- start_states %>%
            dplyr::left_join(entry, by='id') %>%
            dplyr::filter(is.na(Tstop)) %>%
            dplyr::select(id, start_state) %>%
            dplyr::left_join(start_times, by='id') %>%
            dplyr::mutate(start_time = ifelse(is.na(start_time), DEFAULT_START_TIME, start_time)) %>%
            dplyr::rename(from=start_state, Tstart=start_time)

        # And identify those who joined the system but never entered sink state
        last_states <- entry4 %>%
                dplyr::filter(status == 1) %>%
                dplyr::group_by(id) %>%
                dplyr::top_n(1, Tstop) %>%
                dplyr::filter(!to %in% sink_states) %>%
                dplyr::select(id, to, Tstop) %>%
                dplyr::ungroup() %>%
                dplyr::rename(from=to, Tstart=Tstop)

        # Then combine them and work out their censored transitions
        censored_trans <- never_entered_state %>%
            rbind(last_states) %>%
            dplyr::left_join(tmat_long, by='from') %>%
            dplyr::left_join(censors, by='id') %>%
            dplyr::mutate(status=0, time=censor_time - Tstart) %>%
            dplyr::select(id, from, to, trans, Tstart, Tstop=censor_time, time, status)

        # And finally add these censored observations to existing long DF
        entry4 <- entry4 %>%
                rbind(censored_trans)
    }

    if (!is.null(covars)) {
        entry4 <- entry4 %>%
                    dplyr::left_join(covars, by='id')
    }

    to_int <- c('id', 'from', 'to', 'trans', 'status')
    entry4[to_int] <- lapply(entry4[to_int], as.integer)

    out <- entry4 %>%
        dplyr::arrange(id, Tstart, trans)
    attr(out, "trans") <- tmat
    class(out) <- c('msdata', class(out))
    out
}
```

Definisco la matrice di transizione e applico msprep2 ai miei dati.
```{r}
#Controllo degli stati:
table(data_S5$status)
      # Delay MediumDelay      OnTime SevereDelay 
      # 16052        5102       61540        3766 


#Def matrice di transizione:
tmat <- transMat(x = list( c(2), c(1, 3), c(2, 4), c(3) ), names = c("OnTime", "Delay", "MediumDelay", "SevereDelay"))
tmat
#              to
# from          OnTime Delay MediumDelay SevereDelay
#   OnTime          NA     1          NA          NA
#   Delay            2    NA           3          NA
#   MediumDelay     NA     4          NA           5
#   SevereDelay     NA    NA           6          NA
is.circular(tmat) #TRUE --> quindi non posso usare msprep, usiamo un'altra versione:


#Riadatto i miei dati per poter usare la funzione precedente:
#Inserisci un id:
data_S5 <- data_S5 %>%
  mutate(id = dense_rank(ID_Mezzo))
#entry: id, state, time
entry_S5 <- data_S5 %>% dplyr::select(all_of(c("id", "status", "time")))
names(entry_S5)[2]="state"
entry_S5 <- entry_S5 %>%
  arrange(id, time)
entry_S5 <- entry_S5 %>%
  distinct(id, time, .keep_all = TRUE)
#start_times: id, time
start_times_S5 <- data_S5 %>%
  group_by(id) %>%
  slice_head(n = 1)
start_times_S5=start_times_S5[, c("id", "time")]
names(start_times_S5)[2]="start_time"
#start_states: id, state
start_states_S5 <- data_S5 %>%
  group_by(id) %>%
  slice_head(n = 1)
start_states_S5=start_states_S5[, c("id", "status")]
names(start_states_S5)[2]="start_state"
#censors:
censors_S5 <- entry_S5 %>%
  dplyr::group_by(id) %>%
  dplyr::filter(!sink_state %in% state) %>%
  dplyr::summarise(censor_time = max(time, na.rm = TRUE)) %>%
  dplyr::ungroup()
#covars:
covars_S5 <- data_S5 %>%
  group_by(id) %>%
  slice_head(n = 1)
covars_S5=covars_S5[, c("id", "ID_Mezzo", "ID_Treno", "nome", "data", "nome_o", "nome_d", "partenza", "arrivo", "saliti", "scesi", "a_bordo", "direzione", "traffico_ora", "zona")]

#usiamo msprep2:
S5_msdata <- msprep2(entry_S5, tmat, censors=censors_S5, start_times=start_times_S5, start_states=start_states_S5, covars=covars_S5, idcol = "id")
S5_msdata <- S5_msdata[S5_msdata$Tstop > S5_msdata$Tstart, ]
rownames(S5_msdata) <- NULL
head(S5_msdata)
str(S5_msdata)
View(S5_msdata)
class(S5_msdata)
any(is.na(S5_msdata)) #FALSE
S5_msdata<-na.omit(S5_msdata)
S5_msdata$trans=as.factor(S5_msdata$trans)


#Salva dataset:
#write.csv(S5_msdata, file = "S5_msdata.csv", row.names = FALSE)
```


Analisi preliminare: occorrenze e gestione delle covariate.
```{r}
events(S5_msdata)
```


Aggiungi covariate:
```{r}
S5_msdata_cov <- S5_msdata
S5_msdata_cov$zona <- NA
S5_msdata_cov$nome <- NA
S5_msdata_cov$saliti <- NA
S5_msdata_cov$scesi <- NA
S5_msdata_cov$a_bordo <- NA

data_S5$zona <- as.character(data_S5$zona)
for (i in 1:nrow(S5_msdata_cov)) {
  id_mezzo <- S5_msdata_cov$ID_Mezzo[i]
  time_stop <- S5_msdata_cov$Tstop[i]
  for (j in 1:nrow(data_S5)) {
    if (data_S5$ID_Mezzo[j] == id_mezzo && data_S5$time[j] == time_stop) {
      S5_msdata_cov$zona[i] <- data_S5$zona[j]
      S5_msdata_cov$nome[i] <- data_S5$nome[j]
      S5_msdata_cov$saliti[i] <- data_S5$saliti[j]
      S5_msdata_cov$scesi[i] <- data_S5$scesi[j]
      S5_msdata_cov$a_bordo[i] <- data_S5$a_bordo[j]
      break
    }
  }
}

data_S5$zona <- as.factor(data_S5$zona)
S5_msdata_cov$zona <- as.factor(S5_msdata_cov$zona)


#Salva il dataset:
#write.csv(S5_msdata_cov, file = "S5_msdata_cov.csv", row.names = FALSE)
```


## 3 MESI ----

Considero il mese di settembre, ottobre, novembre e proseguo con le mie analisi.
```{r}
S5_msdata$data=as.Date(S5_msdata$data, format = "%Y-%m-%d")

#Direzione 0 (Va-Tre):
msdata_0<-S5_msdata[S5_msdata$direzione==0,]
#View(msdata_0)
dim(msdata_0) #54489    22

#Direzione 1 (Tre-Va):
msdata_1<-S5_msdata[S5_msdata$direzione==1,]
#View(msdata_1)
dim(msdata_1) #51661    22


#Direzione 0 (Va-Tre)_COV:
S5_msdata_cov$data=as.Date(S5_msdata_cov$data, format = "%Y-%m-%d")
S5_msdata_cov$partenza=as.POSIXct(S5_msdata_cov$partenza, format = "%Y-%m-%d %H:%M:%S")
S5_msdata_cov$arrivo=as.POSIXct(S5_msdata_cov$arrivo, format = "%Y-%m-%d %H:%M:%S")
msdata_0_cov<-S5_msdata_cov[S5_msdata_cov$direzione==0,]
dim(msdata_0_cov) #54489    22

#Direzione 1 (Tre-Va)_COV:
msdata_1_cov<-S5_msdata_cov[S5_msdata_cov$direzione==1,]
dim(msdata_1_cov) #51661    22
```


Analisi preliminare per direzione 0: check delle occorrenze dei vari passaggi di stato.
```{r}
#Convert time into minutes:
msdata_0[, c("Tstart", "Tstop", "time")] <- msdata_0[, c("Tstart", "Tstop", "time")]/60

#Salva dataset:
#write.csv(msdata_0, file = "msdata_0.csv", row.names = FALSE)

#Occorrenze per stato:
events(msdata_0)

#Conteggio ID_Mezzo e ID_Treno:
length(unique(msdata_0$ID_Mezzo))
length(unique(msdata_0$ID_Treno))
```


Analisi preliminare della direzione 1: check delle occorrenze dei vari passaggi di stato.
```{r}
#Convert time into minutes:
msdata_1[, c("Tstart", "Tstop", "time")] <- msdata_1[, c("Tstart", "Tstop", "time")]/60

#Salva dataset:
#write.csv(msdata_1, file = "msdata_1.csv", row.names = FALSE)

#Occorrenze per stato:
events(msdata_1)

#Conteggio ID_Mezzo e ID_Treno:
length(unique(msdata_1$ID_Mezzo))
length(unique(msdata_1$ID_Treno))
```


Analisi preliminare della direzione 0 con covariate.
```{r}
#Convert time into minutes:
msdata_0_cov[, c("Tstart", "Tstop", "time")] <- msdata_0_cov[, c("Tstart", "Tstop", "time")]/60

#Salva dataset:
#write.csv(msdata_0_cov, file = "msdata_0_cov.csv", row.names = FALSE)
```


Analisi preliminare della direzione 1 con covariate.
```{r}
#Convert time into minutes:
msdata_1_cov[, c("Tstart", "Tstop", "time")] <- msdata_1_cov[, c("Tstart", "Tstop", "time")]/60

#Salva dataset:
#write.csv(msdata_1_cov, file = "msdata_1_cov.csv", row.names = FALSE)
```


```{r}
#DIREZIONE 0:
# #Divido il dataset complessivo in 3 parti (a seconda di traffico_ora):
# msdata_0_peakm<-msdata_0[msdata_0$traffico_ora=="Morning-Peak Time", ]
# msdata_0_offpeak<-msdata_0[msdata_0$traffico_ora=="Off-Peak Time", ]
# msdata_0_peakp<-msdata_0[msdata_0$traffico_ora=="Evening-Peak Time", ]

#Divido il dataset complessivo in 3 parti (a seconda di PreMi, MiCittà e PostMi):
msdata_0_cov_PreMi.1<-msdata_0_cov[msdata_0_cov$zona=="Pre-Mi.1", ]
msdata_0_cov_PreMi.2<-msdata_0_cov[msdata_0_cov$zona=="Pre-Mi.2", ]
msdata_0_cov_PostMi<-msdata_0_cov[msdata_0_cov$zona=="Post-Mi", ]
msdata_0_cov_Mi<-msdata_0_cov[msdata_0_cov$zona=="Mi-Città", ]


#DIREZIONE 1:
# #Divido il dataset complessivo in 3 parti (a seconda di traffico_ora):
# msdata_1_peakm<-msdata_1[msdata_1$traffico_ora=="Morning-Peak Time", ]
# msdata_1_offpeak<-msdata_1[msdata_1$traffico_ora=="Off-Peak Time", ]
# msdata_1_peakp<-msdata_1[msdata_1$traffico_ora=="Evening-Peak Time", ]

#Divido il dataset complessivo in 3 parti (a seconda di PreMi, MiCittà e PostMi):
msdata_1_cov_PreMi<-msdata_1_cov[msdata_1_cov$zona=="Pre-Mi", ]
msdata_1_cov_PostMi.1<-msdata_1_cov[msdata_1_cov$zona=="Post-Mi.1", ]
msdata_1_cov_PostMi.2<-msdata_1_cov[msdata_1_cov$zona=="Post-Mi.2", ]
msdata_1_cov_Mi<-msdata_1_cov[msdata_1_cov$zona=="Mi-Città", ]
```

## Direzione 0----

### Direzione 0: Fascia Oraria ----
Controllo eventi per ogni sottogruppo:
```{r}
#Peak Mattina:
print("Peak Mattina")
events(msdata_0_peakm)
length(unique(msdata_0_peakm$ID_Mezzo))
length(unique(msdata_0_peakm$ID_Treno))

#Peak Pome:
print("Peak Pome")
events(msdata_0_peakp)
length(unique(msdata_0_peakp$ID_Mezzo))
length(unique(msdata_0_peakp$ID_Treno))

#Off Peak:
print("Off Peak")
events(msdata_0_offpeak)
length(unique(msdata_0_offpeak$ID_Mezzo))
length(unique(msdata_0_offpeak$ID_Treno))
```



MODELLO NP: 

```{r}
#1.A) metodo aalen:
#Peak Mattina:
c0_peakm<-coxph(Surv(time, status) ~ strata(trans), data = msdata_0_peakm, method = "breslow")
msf0_peakm <- msfit(object = c0_peakm, vartype = "aalen", trans = tmat)
summary(msf0_peakm)

#Peak Pome: 
c0_peakp<-coxph(Surv(time, status) ~ strata(trans), data = msdata_0_peakp, method = "breslow")
msf0_peakp <- msfit(object = c0_peakp, vartype = "aalen", trans = tmat)
summary(msf0_peakp)

#Off Peak: 
c0_offpeak<-coxph(Surv(time, status) ~ strata(trans), data = msdata_0_offpeak, method = "breslow")
msf0_offpeak <- msfit(object = c0_offpeak, vartype = "aalen", trans = tmat)
summary(msf0_offpeak)
```

CURVE KAPLAN-MEIER:
```{r}
#Sopravvivenza in orario per tutti e tre i gruppi:
msdata_0_peakm_orario <- msdata_0_peakm[msdata_0_peakm$from == 1, ]
msdata_0_offpeak_orario <- msdata_0_offpeak[msdata_0_offpeak$from == 1, ]
msdata_0_peakp_orario <- msdata_0_peakp[msdata_0_peakp$from == 1, ]


#Sopravvivenza in ritardo grave per tutti e tre i gruppi:
msdata_0_peakm_ritgrave <- msdata_0_peakm[msdata_0_peakm$from == 4, ]
msdata_0_offpeak_ritgrave <- msdata_0_offpeak[msdata_0_offpeak$from == 4, ]
msdata_0_peakp_ritgrave <- msdata_0_peakp[msdata_0_peakp$from == 4, ]


#KAPLAN-MEIER:
#Orario
kaplan_meier_0_orario_peakm <- survfit(Surv(time, status) ~ 1, data = msdata_0_peakm_orario)
kaplan_meier_0_orario_peakp <- survfit(Surv(time, status) ~ 1, data = msdata_0_peakp_orario)
kaplan_meier_0_orario_offpeak <- survfit(Surv(time, status) ~ 1, data = msdata_0_offpeak_orario)


#Ritardo grave
kaplan_meier_0_ritgrave_peakm <- survfit(Surv(time, status) ~ 1, data = msdata_0_peakm_ritgrave)
kaplan_meier_0_ritgrave_peakp <- survfit(Surv(time, status) ~ 1, data = msdata_0_peakp_ritgrave)
kaplan_meier_0_ritgrave_offpeak <- survfit(Surv(time, status) ~ 1, data = msdata_0_offpeak_ritgrave)
```

Plot:
```{r}
# Imposta la griglia di plot
par(mfrow=c(1,2))

# SOPRAVVIVENZA IN ORARIO:
plot(kaplan_meier_0_orario_peakm, xlab = "Time (min)", ylab = "Survival in the current state", 
     main = "From OnTime to Delay", col="#87CEFA", lwd = 2, conf.int=FALSE, xlim = c(0,20))
lines(kaplan_meier_0_orario_offpeak, col = "#EB5C82", lwd = 2, conf.int=FALSE)
lines(kaplan_meier_0_orario_peakp, col = "#F59B51", lwd = 2, conf.int=FALSE)
legend("bottomleft", legend = c("Morning Peak", "Off Peak", "Evening Peak"), 
       col = c("#87CEFA", "#EB5C82", "#F59B51"), bty = "n", lwd = 2, cex = 1.2)


# SOPRAVVIVENZA IN RITARDO GRAVE:
plot(kaplan_meier_0_ritgrave_peakm, xlab = "Time (min)", ylab = "Survival in the current state", 
     main = "From SevereDelay to MediumDelay", col="#87CEFA", lwd = 2, conf.int=FALSE, xlim = c(0,15))
lines(kaplan_meier_0_ritgrave_offpeak, col = "#EB5C82", lwd = 2, conf.int=FALSE)
lines(kaplan_meier_0_ritgrave_peakp, col = "#F59B51", lwd = 2, conf.int=FALSE)
```


PROBABILITA' DI TRANSIZIONE:
```{r}
#Probabilità di transizione di lì a :
pt0_peakm <- probtrans(msf0_peakm, predt = 0, method = "aalen")

pt0_peakp <- probtrans(msf0_peakp, predt = 0, method = "aalen")

pt0_offpeak <- probtrans(msf0_offpeak, predt = 0, method = "aalen")


statecols <- c("#C3EEBF", "#FBDD88", "#f78464", "#E05265")
ord <- c(1,2,3,4)
#plot Peak mattina: 
p1<-plot(pt0_peakm, ord = ord, from=1, xlim=c(0,30), use.ggplot = TRUE)
p1 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from OnTime)",x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))  # Modifica il titolo della legenda
#
p2<-plot(pt0_peakm, ord = ord, from=2, xlim=c(0,30), use.ggplot = TRUE)
p2 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from Delay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))  # Modifica il titolo della legenda
#
p3<-plot(pt0_peakm, ord = ord, from=3, xlim=c(0,30), use.ggplot = TRUE)
p3 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from MediumDelay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))
#
p4<-plot(pt0_peakm, ord = ord, from=4, xlim=c(0,30), use.ggplot = TRUE)
p4 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from SevereDelay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))

#plot Off peak:
p5<-plot(pt0_offpeak, ord = ord, from=1, xlim=c(0,30), use.ggplot = TRUE)
p5 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from OnTime)",x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))  # Modifica il titolo della legenda
#
p6<-plot(pt0_offpeak, ord = ord, from=2, xlim=c(0,30), use.ggplot = TRUE)
p6 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from Delay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))  # Modifica il titolo della legenda
#
p7<-plot(pt0_offpeak, ord = ord, from=3, xlim=c(0,30), use.ggplot = TRUE)
p7 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from MediumDelay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))
#
p8<-plot(pt0_offpeak, ord = ord, from=4, xlim=c(0,30), use.ggplot = TRUE)
p8 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from SevereDelay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))

#plot Peak pome:
p9<-plot(pt0_peakp, ord = ord, from=1, xlim=c(0,30), use.ggplot = TRUE)
p9 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from OnTime)",x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))  # Modifica il titolo della legenda
#
p10<-plot(pt0_peakp, ord = ord, from=2, xlim=c(0,30), use.ggplot = TRUE)
p10 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from Delay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))  # Modifica il titolo della legenda
#
p11<-plot(pt0_peakp, ord = ord, from=3, xlim=c(0,30), use.ggplot = TRUE)
p11 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from MediumDelay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))
#
p12<-plot(pt0_peakp, ord = ord, from=4, xlim=c(0,30), use.ggplot = TRUE)
p12 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from SevereDelay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))


grid.arrange(p1 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From OnTime", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p2 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From Delay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p3 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From MediumDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p4 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p5 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From OnTime", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p6 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From Delay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p7 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From MediumDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p8 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p9 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From OnTime", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p10 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From Delay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p11 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From MediumDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p12 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             nrow= 3, ncol = 4)  # Questo imposta 2 colonne
```




AIC del modello:
```{r}
AIC(c0_peakm)
AIC(c0_offpeak)
AIC(c0_peakp)
```

ELOS: Expected Lenght of Stay
Dall'help di R: Given a "probtrans" object, ELOS calculates the (restricted) expected length of stay in each of the states of the multi-state model.
ELOS(pt, tau)
The object pt needs to be a "probtrans" object, obtained with forward prediction. The restriction to tau is there because, as in ordinary survival analysis, the probability of being in a state can be positive until infinity, resulting in infinite values. The (restricted, until tau) expected length of stay in state h, given in state g at time s, is given by the integral from s to tau of P_gh(s,t).
```{r}
# pt0_peakm <- probtrans(msf0_peakm, predt = 0, method = "aalen")
# pt0_peakp <- probtrans(msf0_peakp, predt = 0, method = "aalen")
# pt0_offpeak <- probtrans(msf0_offpeak, predt = 0, method = "aalen")
ELOS(pt0_peakm, 130)
ELOS(pt0_offpeak, 130)
ELOS(pt0_peakp, 130)
```







### Direzione 0: Zona Tratta ----

Controllo eventi per ogni sottogruppo:
```{r}
#Pre-Milano.1:
print("Pre-Milano.1")
events(msdata_0_cov_PreMi.1)
length(unique(msdata_0_cov_PreMi.1$ID_Mezzo))
length(unique(msdata_0_cov_PreMi.1$ID_Treno))

#Pre-Milano.2:
print("Pre-Milano.2")
events(msdata_0_cov_PreMi.2)
length(unique(msdata_0_cov_PreMi.2$ID_Mezzo))
length(unique(msdata_0_cov_PreMi.2$ID_Treno))

#Post-Milano:
print("Post-Milano")
events(msdata_0_cov_PostMi)
length(unique(msdata_0_cov_PostMi$ID_Mezzo))
length(unique(msdata_0_cov_PostMi$ID_Treno))

#Milano-Città:
print("Milano")
events(msdata_0_cov_Mi)
length(unique(msdata_0_cov_Mi$ID_Mezzo))
length(unique(msdata_0_cov_Mi$ID_Treno))
```


#### Modello NP----

```{r}
#1.A) metodo aalen:
#Pre-Mialno.1:
c0_PreMi.1<-coxph(Surv(time, status) ~ strata(trans), data = msdata_0_cov_PreMi.1, method = "breslow")
msf0_PreMi.1 <- msfit(object = c0_PreMi.1, vartype = "aalen", trans = tmat)
summary(msf0_PreMi.1)

#Pre-Mialno.2:
c0_PreMi.2<-coxph(Surv(time, status) ~ strata(trans), data = msdata_0_cov_PreMi.2, method = "breslow")
msf0_PreMi.2 <- msfit(object = c0_PreMi.2, vartype = "aalen", trans = tmat)
summary(msf0_PreMi.2)

#Post-Milano: 
c0_PostMi<-coxph(Surv(time, status) ~ strata(trans), data = msdata_0_cov_PostMi, method = "breslow")
msf0_PostMi <- msfit(object = c0_PostMi, vartype = "aalen", trans = tmat)
summary(msf0_PostMi)

#Milano-Città: 
c0_Mi<-coxph(Surv(time, status) ~ strata(trans), data = msdata_0_cov_Mi, method = "breslow")
msf0_Mi <- msfit(object = c0_Mi, vartype = "aalen", trans = tmat)
summary(msf0_Mi)
```

CURVE KAPLAN-MEIER:
```{r}
#Sopravvivenza in orario per tutti e tre i gruppi:
msdata_0_PreMi.1_orario <- msdata_0_cov_PreMi.1[msdata_0_cov_PreMi.1$from == 1, ]
msdata_0_PreMi.2_orario <- msdata_0_cov_PreMi.2[msdata_0_cov_PreMi.2$from == 1, ]
msdata_0_Mi_orario <- msdata_0_cov_Mi[msdata_0_cov_Mi$from == 1, ]
msdata_0_PostMi_orario <- msdata_0_cov_PostMi[msdata_0_cov_PostMi$from == 1, ]

#Sopravvivenza in ritardo grave per tutti e tre i gruppi:
msdata_0_PreMi.1_ritgrave <- msdata_0_cov_PreMi.1[msdata_0_cov_PreMi.1$from == 4, ]
msdata_0_PreMi.2_ritgrave <- msdata_0_cov_PreMi.2[msdata_0_cov_PreMi.2$from == 4, ]
msdata_0_Mi_ritgrave <- msdata_0_cov_Mi[msdata_0_cov_Mi$from == 4, ]
msdata_0_PostMi_ritgrave <- msdata_0_cov_PostMi[msdata_0_cov_PostMi$from == 4, ]


#KAPLAN-MEIER:
#Orario
kaplan_meier_0_orario_PreMi.1 <- survfit(Surv(time, status) ~ 1, data = msdata_0_PreMi.1_orario)
kaplan_meier_0_orario_PreMi.2 <- survfit(Surv(time, status) ~ 1, data = msdata_0_PreMi.2_orario)
kaplan_meier_0_orario_Mi <- survfit(Surv(time, status) ~ 1, data = msdata_0_Mi_orario)
kaplan_meier_0_orario_PostMi <- survfit(Surv(time, status) ~ 1, data = msdata_0_PostMi_orario)

#Ritardo grave
kaplan_meier_0_ritgrave_PreMi.1 <- survfit(Surv(time, status) ~ 1, data = msdata_0_PreMi.1_ritgrave)
kaplan_meier_0_ritgrave_PreMi.2 <- survfit(Surv(time, status) ~ 1, data = msdata_0_PreMi.2_ritgrave)
kaplan_meier_0_ritgrave_Mi <- survfit(Surv(time, status) ~ 1, data = msdata_0_Mi_ritgrave)
kaplan_meier_0_ritgrave_PostMi <- survfit(Surv(time, status) ~ 1, data = msdata_0_PostMi_ritgrave)
```

Plot:
```{r}
# Imposta la griglia di plot
par(mfrow=c(1,2))

# SOPRAVVIVENZA IN ORARIO:
plot(kaplan_meier_0_orario_PreMi.1, xlab = "Time (min)", ylab = "Survival in the current state", 
     main = "From OnTime to Delay", col="#87CEFA", lwd = 2, conf.int=FALSE, xlim=c(0,25))
lines(kaplan_meier_0_orario_PreMi.2, col = "#00B88D", lwd = 2, conf.int=FALSE)
lines(kaplan_meier_0_orario_Mi, col = "#EB5C82", lwd = 2, conf.int=FALSE)
lines(kaplan_meier_0_orario_PostMi, col = "#F59B51", lwd = 2, conf.int=FALSE)
legend("bottomleft", legend = c("Pre-Milano.1", "Pre-Milano.2", "Milano", "Post-Milano"), 
       col = c("#87CEFA", "#00B88D", "#EB5C82", "#F59B51"), bty = "n", lwd = 2, cex = 1.2)

# SOPRAVVIVENZA IN RITARDO GRAVE:
plot(kaplan_meier_0_ritgrave_PreMi.1, xlab = "Time (min)", ylab = "Survival in the current state", 
     main = "From SevereDelay to Delay", col="#87CEFA", lwd = 2, xlim = c(0, 10), conf.int=FALSE)
lines(kaplan_meier_0_ritgrave_PreMi.2, col = "#00B88D", lwd = 2, conf.int=FALSE)
lines(kaplan_meier_0_ritgrave_Mi, col = "#EB5C82", lwd = 2, conf.int=FALSE)
lines(kaplan_meier_0_ritgrave_PostMi, col = "#F59B51", lwd = 2, conf.int=FALSE)
```


PROBABILITA' DI TRANSIZIONE:
```{r}
#Probabilità di transizione di lì a :
pt0_PreMi.1 <- probtrans(msf0_PreMi.1, predt = 0, method = "aalen")

pt0_PreMi.2 <- probtrans(msf0_PreMi.2, predt = 0, method = "aalen")

pt0_Mi <- probtrans(msf0_Mi, predt = 0, method = "aalen")

pt0_PostMi <- probtrans(msf0_PostMi, predt = 0, method = "aalen")


# statecols <- c("#C3EEBF", "#FBDD88", "#E05265")
# ord <- c(1,2,3)
#plot: 
p1<-plot(pt0_PreMi.1, ord = ord, from=1, xlim = c(0,20), use.ggplot = TRUE)
p2<-plot(pt0_PreMi.1, ord = ord, from=2, xlim = c(0,20), use.ggplot = TRUE)
p3<-plot(pt0_PreMi.1, ord = ord, from=3, xlim = c(0,20), use.ggplot = TRUE)
p4<-plot(pt0_PreMi.1, ord = ord, from=4, xlim = c(0,20), use.ggplot = TRUE)
p5<-plot(pt0_PreMi.2, ord = ord, from=1, xlim = c(0,20), use.ggplot = TRUE)
p6<-plot(pt0_PreMi.2, ord = ord, from=2, xlim = c(0,20), use.ggplot = TRUE)
p7<-plot(pt0_PreMi.2, ord = ord, from=3, xlim = c(0,20), use.ggplot = TRUE)
p8<-plot(pt0_PreMi.2, ord = ord, from=4, xlim = c(0,20), use.ggplot = TRUE)
p9<-plot(pt0_Mi, ord = ord, from=1, xlim = c(0,20), use.ggplot = TRUE)
p10<-plot(pt0_Mi, ord = ord, from=2, xlim = c(0,20), use.ggplot = TRUE)
p11<-plot(pt0_Mi, ord = ord, from=3, xlim = c(0,20), use.ggplot = TRUE)
p12<-plot(pt0_Mi, ord = ord, from=4, xlim = c(0,20), use.ggplot = TRUE)
p13<-plot(pt0_PostMi, ord = ord, from=1, xlim = c(0,20), use.ggplot = TRUE)
p14<-plot(pt0_PostMi, ord = ord, from=2, xlim = c(0,20), use.ggplot = TRUE)
p15<-plot(pt0_PostMi, ord = ord, from=3, xlim = c(0,20), use.ggplot = TRUE)
p16<-plot(pt0_PostMi, ord = ord, from=4, xlim = c(0,20), use.ggplot = TRUE)


grid.arrange(p1 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From OnTime", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p2 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From Delay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p3 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p4 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From OnTime", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p5 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From Delay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p6 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p7 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From OnTime", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p8 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From Delay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p9 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p10 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From OnTime", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p11 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From Delay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p12 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             p13 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p14 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From OnTime", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p15 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From Delay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p16 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             nrow= 4, ncol = 4)  # Questo imposta 2 colonne
```


AIC del modello:
```{r}
AIC(c0_PreMi.1)
AIC(c0_PreMi.2)
AIC(c0_Mi)
AIC(c0_PostMi)
```

ELOS: Expected Lenght of Stay
Dall'help di R: Given a "probtrans" object, ELOS calculates the (restricted) expected length of stay in each of the states of the multi-state model.
ELOS(pt, tau)
The object pt needs to be a "probtrans" object, obtained with forward prediction. The restriction to tau is there because, as in ordinary survival analysis, the probability of being in a state can be positive until infinity, resulting in infinite values. The (restricted, until tau) expected length of stay in state h, given in state g at time s, is given by the integral from s to tau of P_gh(s,t).
```{r}
# pt0_PreMi.1 <- probtrans(msf0_PreMi.1, predt = 0, method = "aalen")
# pt0_PreMi.2 <- probtrans(msf0_PreMi.2, predt = 0, method = "aalen")
# pt0_Mi <- probtrans(msf0_Mi, predt = 0, method = "aalen")
# pt0_PostMi <- probtrans(msf0_PostMi, predt = 0, method = "aalen")

ELOS(pt0_PreMi.1, 30)
ELOS(pt0_PreMi.2, 30)
ELOS(pt0_Mi, 30)
ELOS(pt0_PostMi, 30)
```









## Direzione 1----

### Direzione 1: Fascia Oraria ----

Analisi descrittiva dei ritardi per fascia oraria in direzioni diverse:
```{r}
# Tratta intera (usuale):
# - Varese
# - Gazzada
# - Castronno
# - Albizzate
# - Cavaria
# - Gallarate
# - Busto
# - Legnano
# - Canegrate
# - Parabiago
# - Vanzago
# - Rho
# - Rho Fiera
# - Mi Certosa
# - Mi VIllapizzone
# - Mi Lancetti
# - Mi P. Garibaldi
# - Mi Repubblica
# - Mi P. Venezia
# - Mi Dateo
# - Mi P. Vittoria
# - Mi Forlanini
# - Segrate
# - Pioltello
# - Vignate
# - Melzo
# - Pozzuolo Martesana
# - Trecella
# - Cassano D'Adda
# - Treviglio

#Station_list

# Funzione per calcolare le statistiche
calcola_statistiche <- function(subset_df) {
  # Controlliamo se ora_ingresso non è l'ora di default
  if(all(subset_df$ora_ingresso != as.POSIXct("1970-01-01 01:00:00"))) {
    ritardo_medio <- mean(subset_df$ritardo_ingresso, na.rm = TRUE)
    sd_ritardo <- sd(subset_df$ritardo_ingresso, na.rm = TRUE)
  } else {
    ritardo_medio <- mean(subset_df$ritardo_uscita, na.rm = TRUE)
    sd_ritardo <- sd(subset_df$ritardo_uscita, na.rm = TRUE)
  }

  lower_bound <- ritardo_medio - 2 * sd_ritardo
  upper_bound <- ritardo_medio + 2 * sd_ritardo

  return(tibble(
    stazione = unique(subset_df$stazione),
    traffico_ora = unique(subset_df$traffico_ora),
    direzione = unique(subset_df$direzione),
    ritardo_medio = ritardo_medio,
    sd_ritardo = sd_ritardo,
    lower_bound = lower_bound,
    upper_bound = upper_bound
  ))
}

# Raggruppiamo i dati per stazione, fascia oraria e direzione e applichiamo la funzione
risultato <- data_S5 %>%
  group_by(nome, traffico_ora, direzione) %>%
  do(calcola_statistiche(.))

# Convertiamo i ritardi in minuti
risultato <- risultato %>%
  mutate(
    ritardo_medio = ritardo_medio / 60,
    sd_ritardo = sd_ritardo / 60,
    lower_bound = lower_bound / 60,
    upper_bound = upper_bound / 60
  )

# Visualizza il risultato
# View(risultato)




#Plot:
risultato$nome <- factor(risultato$nome, levels = Station_list)

# Filtra i dati per direzione 0
risultato_direzione_0 <- risultato %>% filter(direzione == 0)

# Grafico per la direzione 0
ggplot(risultato_direzione_0, aes(x = nome, y = ritardo_medio, group = traffico_ora, color = traffico_ora)) +
  geom_line(linewidth = 1) +  # Usa 'linewidth' al posto di 'size'
  geom_ribbon(aes(ymin = lower_bound, ymax = upper_bound, fill = traffico_ora), alpha = 0.3) +
  geom_point(size = 2) +
  scale_color_manual(values = c("Morning-Peak Time" = "#87CEFA", 
                               "Evening-Peak Time" = "#F59B51", 
                               "Off-Peak Time" = "#EB5C82")) +
  scale_fill_manual(values = c("Morning-Peak Time" = "#C4E7FD", 
                              "Evening-Peak Time" = "#F9C79F", 
                              "Off-Peak Time" = "#F4A4B9")) +
  theme_minimal() +
  labs(
    title = "Mean Delays - Direction 0",
    x = "Station",
    y = "Delay (min)",
    color = "Time Slot",
    fill = "Time Slot"
  ) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))  # Ruota le etichette delle stazioni per migliorare la leggibilità



#Inverto l'ordine delle stazioni per la direzione 1:
risultato$nome <- factor(risultato$nome, levels = rev(Station_list))

# Filtra i dati per direzione 1
risultato_direzione_1 <- risultato %>% filter(direzione == 1)

# Inverti l'ordine delle stazioni
risultato_direzione_1 <- risultato_direzione_1 %>%
  mutate(nome = factor(nome, levels = rev(unique(nome))))

# Grafico per la direzione 1 con ordine invertito delle stazioni
ggplot(risultato_direzione_1, aes(x = nome, y = ritardo_medio, group = traffico_ora, color = traffico_ora)) +
  geom_line(linewidth = 1) +  # Usa 'linewidth' al posto di 'size'
  geom_ribbon(aes(ymin = lower_bound, ymax = upper_bound, fill = traffico_ora), alpha = 0.3) +
  geom_point(size = 2) +
  scale_color_manual(values = c("Morning-Peak Time" = "#87CEFA", 
                               "Evening-Peak Time" = "#F59B51", 
                               "Off-Peak Time" = "#EB5C82")) +
  scale_fill_manual(values = c("Morning-Peak Time" = "#C4E7FD", 
                              "Evening-Peak Time" = "#F9C79F", 
                              "Off-Peak Time" = "#F4A4B9")) +
  theme_minimal() +
  labs(
    title = "Mean Delays - Direction 1",
    x = "Station",
    y = "Delay (min)",
    color = "Time Slot",
    fill = "Time Slot"
  ) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))  # Ruota le etichette delle stazioni per migliorare la leggibilità
```


Controllo eventi per ogni sottogruppo:
```{r}
#Peak Mattina:
print("Peak Mattina")
events(msdata_1_peakm)
length(unique(msdata_1_peakm$ID_Mezzo))
length(unique(msdata_1_peakm$ID_Treno))

#Peak Pome:
print("Peak Pome")
events(msdata_1_peakp)
length(unique(msdata_1_peakp$ID_Mezzo))
length(unique(msdata_1_peakp$ID_Treno))

#Off Peak:
print("Off Peak")
events(msdata_1_offpeak)
length(unique(msdata_1_offpeak$ID_Mezzo))
length(unique(msdata_1_offpeak$ID_Treno))
```



#### Modello NP - direzione 1 Fascia Oraria----

```{r}
#1.A) metodo aalen:
#Peak Mattina:
c1_peakm<-coxph(Surv(time, status) ~ strata(trans), data = msdata_1_peakm, method = "breslow")
msf1_peakm <- msfit(object = c1_peakm, vartype = "aalen", trans = tmat)
summary(msf1_peakm)

#Peak Pome: 
c1_peakp<-coxph(Surv(time, status) ~ strata(trans), data = msdata_1_peakp, method = "breslow")
msf1_peakp <- msfit(object = c1_peakp, vartype = "aalen", trans = tmat)
summary(msf1_peakp)

#Off Peak: 
c1_offpeak<-coxph(Surv(time, status) ~ strata(trans), data = msdata_1_offpeak, method = "breslow")
msf1_offpeak <- msfit(object = c1_offpeak, vartype = "aalen", trans = tmat)
summary(msf1_offpeak)
```

CURVE KAPLAN-MEIER:
```{r}
#Sopravvivenza in orario per tutti e tre i gruppi:
msdata_1_peakm_orario <- msdata_1_peakm[msdata_1_peakm$from == 1, ]
msdata_1_offpeak_orario <- msdata_1_offpeak[msdata_1_offpeak$from == 1, ]
msdata_1_peakp_orario <- msdata_1_peakp[msdata_1_peakp$from == 1, ]


#Sopravvivenza in ritardo grave per tutti e tre i gruppi:
msdata_1_peakm_ritgrave <- msdata_1_peakm[msdata_1_peakm$from == 4, ]
msdata_1_offpeak_ritgrave <- msdata_1_offpeak[msdata_1_offpeak$from == 4, ]
msdata_1_peakp_ritgrave <- msdata_1_peakp[msdata_1_peakp$from == 4, ]


#KAPLAN-MEIER:
#Orario
kaplan_meier_1_orario_peakm <- survfit(Surv(time, status) ~ 1, data = msdata_1_peakm_orario)
kaplan_meier_1_orario_peakp <- survfit(Surv(time, status) ~ 1, data = msdata_1_peakp_orario)
kaplan_meier_1_orario_offpeak <- survfit(Surv(time, status) ~ 1, data = msdata_1_offpeak_orario)


#Ritardo grave
kaplan_meier_1_ritgrave_peakm <- survfit(Surv(time, status) ~ 1, data = msdata_1_peakm_ritgrave)
kaplan_meier_1_ritgrave_peakp <- survfit(Surv(time, status) ~ 1, data = msdata_1_peakp_ritgrave)
kaplan_meier_1_ritgrave_offpeak <- survfit(Surv(time, status) ~ 1, data = msdata_1_offpeak_ritgrave)
```

Plot:
```{r}
# Imposta la griglia di plot
par(mfrow=c(1,2))

# SOPRAVVIVENZA IN ORARIO:
plot(kaplan_meier_1_orario_peakm, xlab = "Time (min)", ylab = "Survival in the current state", 
     main = "From OnTime to Delay", col="#87CEFA", lwd = 2, conf.int=FALSE, xlim = c(0,20))
lines(kaplan_meier_1_orario_offpeak, col = "#EB5C82", lwd = 2, conf.int=FALSE)
lines(kaplan_meier_1_orario_peakp, col = "#F59B51", lwd = 2, conf.int=FALSE)
legend("bottomleft", legend = c("Morning Peak", "Off Peak", "Evening Peak"), 
       col = c("#87CEFA", "#EB5C82", "#F59B51"), bty = "n", lwd = 2, cex = 1.2)


# SOPRAVVIVENZA IN RITARDO GRAVE:
plot(kaplan_meier_1_ritgrave_peakm, xlab = "Time (min)", ylab = "Survival in the current state", 
     main = "From SevereDelay to MediumDelay", col="#87CEFA", lwd = 2, conf.int=FALSE, xlim = c(0,20))
lines(kaplan_meier_1_ritgrave_offpeak, col = "#EB5C82", lwd = 2, conf.int=FALSE)
lines(kaplan_meier_1_ritgrave_peakp, col = "#F59B51", lwd = 2, conf.int=FALSE)
```


PROBABILITA' DI TRANSIZIONE:
```{r}
#Probabilità di transizione di lì a :
pt1_peakm <- probtrans(msf1_peakm, predt = 0, method = "aalen")

pt1_peakp <- probtrans(msf1_peakp, predt = 0, method = "aalen")

pt1_offpeak <- probtrans(msf1_offpeak, predt = 0, method = "aalen")


statecols <- c("#C3EEBF", "#FBDD88", "#f78464", "#E05265")
ord <- c(1,2,3,4)
#plot Peak mattina: 
p1<-plot(pt1_peakm, ord = ord, from=1, xlim=c(0,30), use.ggplot = TRUE)
p1 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from OnTime)",x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))  # Modifica il titolo della legenda
#
p2<-plot(pt1_peakm, ord = ord, from=2, xlim=c(0,30), use.ggplot = TRUE)
p2 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from Delay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))  # Modifica il titolo della legenda
#
p3<-plot(pt1_peakm, ord = ord, from=3, xlim=c(0,30), use.ggplot = TRUE)
p3 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from MediumDelay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))
#
p4<-plot(pt1_peakm, ord = ord, from=4, xlim=c(0,30), use.ggplot = TRUE)
p4 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from SevereDelay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))

#plot Off peak:
p5<-plot(pt1_offpeak, ord = ord, from=1, xlim=c(0,30), use.ggplot = TRUE)
p5 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from OnTime)",x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))  # Modifica il titolo della legenda
#
p6<-plot(pt1_offpeak, ord = ord, from=2, xlim=c(0,30), use.ggplot = TRUE)
p6 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from Delay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))  # Modifica il titolo della legenda
#
p7<-plot(pt1_offpeak, ord = ord, from=3, xlim=c(0,30), use.ggplot = TRUE)
p7 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from MediumDelay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))
#
p8<-plot(pt1_offpeak, ord = ord, from=4, xlim=c(0,30), use.ggplot = TRUE)
p8 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from SevereDelay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))

#plot Peak pome:
p9<-plot(pt1_peakp, ord = ord, from=1, xlim=c(0,30), use.ggplot = TRUE)
p9 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from OnTime)",x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))  # Modifica il titolo della legenda
#
p10<-plot(pt1_peakp, ord = ord, from=2, xlim=c(0,30), use.ggplot = TRUE)
p10 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from Delay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))  # Modifica il titolo della legenda
#
p11<-plot(pt1_peakp, ord = ord, from=3, xlim=c(0,30), use.ggplot = TRUE)
p11 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from MediumDelay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))
#
p12<-plot(pt1_peakp, ord = ord, from=4, xlim=c(0,30), use.ggplot = TRUE)
p12 + 
  scale_fill_manual(values = statecols) +
  theme_minimal() + 
  labs(title = "Transition Probabilities (starting from SevereDelay)", x = "Time (Minutes)", y = "Probability") +  # Aggiungi etichette
  guides(fill = guide_legend(title = "States"))


grid.arrange(p1 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From OnTime", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p2 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From Delay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p3 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From MediumDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p4 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p5 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From OnTime", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p6 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From Delay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p7 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From MediumDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p8 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p9 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From OnTime", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p10 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From Delay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p11 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From MediumDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p12 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             nrow= 3, ncol = 4)  # Questo imposta 2 colonne
```



AIC del modello:
```{r}
AIC(c1_peakm)
AIC(c1_offpeak)
AIC(c1_peakp)
```


ELOS: Expected Lenght of Stay
Dall'help di R: Given a "probtrans" object, ELOS calculates the (restricted) expected length of stay in each of the states of the multi-state model.
ELOS(pt, tau)
The object pt needs to be a "probtrans" object, obtained with forward prediction. The restriction to tau is there because, as in ordinary survival analysis, the probability of being in a state can be positive until infinity, resulting in infinite values. The (restricted, until tau) expected length of stay in state h, given in state g at time s, is given by the integral from s to tau of P_gh(s,t).
```{r}
# pt1_peakm <- probtrans(msf1_peakm, predt = 0, method = "aalen")
# pt1_peakp <- probtrans(msf1_peakp, predt = 0, method = "aalen")
# pt1_offpeak <- probtrans(msf1_offpeak, predt = 0, method = "aalen")

ELOS(pt1_peakm)
ELOS(pt1_offpeak)
ELOS(pt1_peakp)
```


### Direzione 1: Zona Tratta ----


Controllo eventi per ogni sottogruppo:
```{r}
#Pre-Milano:
print("Pre-Milano")
events(msdata_1_cov_PreMi)
length(unique(msdata_1_cov_PreMi$ID_Mezzo))
length(unique(msdata_1_cov_PreMi$ID_Treno))

#Post-Milano.1:
print("Post-Milano.1")
events(msdata_1_cov_PostMi.1)
length(unique(msdata_1_cov_PostMi.1$ID_Mezzo))
length(unique(msdata_1_cov_PostMi.1$ID_Treno))

#Post-Milano.2:
print("Post-Milano.2")
events(msdata_1_cov_PostMi.2)
length(unique(msdata_1_cov_PostMi.2$ID_Mezzo))
length(unique(msdata_1_cov_PostMi.2$ID_Treno))

#Milano-Città:
print("Milano")
events(msdata_1_cov_Mi)
length(unique(msdata_1_cov_Mi$ID_Mezzo))
length(unique(msdata_1_cov_Mi$ID_Treno))
```


#### Modello NP----

```{r}
#1.A) metodo aalen:
#Pre-Mialno:
c1_PreMi<-coxph(Surv(time, status) ~ strata(trans), data = msdata_1_cov_PreMi, method = "breslow")
msf1_PreMi <- msfit(object = c1_PreMi, vartype = "aalen", trans = tmat)
summary(msf1_PreMi)

#Post-Milano.1: 
c1_PostMi.1<-coxph(Surv(time, status) ~ strata(trans), data = msdata_1_cov_PostMi.1, method = "breslow")
msf1_PostMi.1 <- msfit(object = c1_PostMi.1, vartype = "aalen", trans = tmat)
summary(msf1_PostMi.1)

#Post-Milano.2: 
c1_PostMi.2<-coxph(Surv(time, status) ~ strata(trans), data = msdata_1_cov_PostMi.2, method = "breslow")
msf1_PostMi.2 <- msfit(object = c1_PostMi.2, vartype = "aalen", trans = tmat)
summary(msf1_PostMi.2)

#Milano-Città: 
c1_Mi<-coxph(Surv(time, status) ~ strata(trans), data = msdata_1_cov_Mi, method = "breslow")
msf1_Mi <- msfit(object = c1_Mi, vartype = "aalen", trans = tmat)
summary(msf1_Mi)
```

CURVE KAPLAN-MEIER:
```{r}
#Sopravvivenza in orario per tutti e tre i gruppi:
msdata_1_PreMi_orario <- msdata_1_cov_PreMi[msdata_1_cov_PreMi$from == 1, ]
msdata_1_Mi_orario <- msdata_1_cov_Mi[msdata_1_cov_Mi$from == 1, ]
msdata_1_PostMi.1_orario <- msdata_1_cov_PostMi.1[msdata_1_cov_PostMi.1$from == 1, ]
msdata_1_PostMi.2_orario <- msdata_1_cov_PostMi.2[msdata_1_cov_PostMi.2$from == 1, ]

#Sopravvivenza in ritardo grave per tutti e tre i gruppi:
msdata_1_PreMi_ritgrave <- msdata_1_cov_PreMi[msdata_1_cov_PreMi$from == 3, ]
msdata_1_Mi_ritgrave <- msdata_1_cov_Mi[msdata_1_cov_Mi$from == 3, ]
msdata_1_PostMi.1_ritgrave <- msdata_1_cov_PostMi.1[msdata_1_cov_PostMi.1$from == 3, ]
msdata_1_PostMi.2_ritgrave <- msdata_1_cov_PostMi.2[msdata_1_cov_PostMi.2$from == 3, ]


#KAPLAN-MEIER:
#Orario
kaplan_meier_1_orario_PreMi <- survfit(Surv(time, status) ~ 1, data = msdata_1_PreMi_orario)
kaplan_meier_1_orario_Mi <- survfit(Surv(time, status) ~ 1, data = msdata_1_Mi_orario)
kaplan_meier_1_orario_PostMi.1 <- survfit(Surv(time, status) ~ 1, data = msdata_1_PostMi.1_orario)
kaplan_meier_1_orario_PostMi.2 <- survfit(Surv(time, status) ~ 1, data = msdata_1_PostMi.2_orario)

#Ritardo grave
kaplan_meier_1_ritgrave_PreMi <- survfit(Surv(time, status) ~ 1, data = msdata_1_PreMi_ritgrave)
kaplan_meier_1_ritgrave_Mi <- survfit(Surv(time, status) ~ 1, data = msdata_1_Mi_ritgrave)
kaplan_meier_1_ritgrave_PostMi.1 <- survfit(Surv(time, status) ~ 1, data = msdata_1_PostMi.1_ritgrave)
kaplan_meier_1_ritgrave_PostMi.2 <- survfit(Surv(time, status) ~ 1, data = msdata_1_PostMi.2_ritgrave)
```

Plot:
```{r}
# Imposta la griglia di plot
par(mfrow=c(1,2))

# SOPRAVVIVENZA IN ORARIO:
plot(kaplan_meier_1_orario_PreMi, xlab = "Time (min)", ylab = "Survival in the current state", 
     main = "From OnTime to Delay", col="#87CEFA", lwd = 2, conf.int=FALSE, xlim=c(0,15))
lines(kaplan_meier_1_orario_Mi, col = "#EB5C82", lwd = 2, conf.int=FALSE)
lines(kaplan_meier_1_orario_PostMi.1, col = "#F59B51", lwd = 2, conf.int=FALSE)
lines(kaplan_meier_1_orario_PostMi.2, col = "#00B88D", lwd = 2, conf.int=FALSE)
legend("bottomleft", legend = c("Pre-Milano", "Milano", "Post-Milano.1", "Post-Milano.2"), 
       col = c("#87CEFA", "#EB5C82", "#F59B51", "#00B88D"), bty = "n", lwd = 2, cex = 1.2)

# SOPRAVVIVENZA IN RITARDO GRAVE:
plot(kaplan_meier_1_ritgrave_PreMi, xlab = "Time (min)", ylab = "Survival in the current state", 
     main = "From SevereDelay to Delay", col="#87CEFA", lwd = 2, xlim = c(0, 20), conf.int=FALSE)
lines(kaplan_meier_1_ritgrave_Mi, col = "#EB5C82", lwd = 2, conf.int=FALSE)
lines(kaplan_meier_1_ritgrave_PostMi.1, col = "#F59B51", lwd = 2, conf.int=FALSE)
lines(kaplan_meier_1_ritgrave_PostMi.2, col = "#00B88D", lwd = 2, conf.int=FALSE)
```


PROBABILITA' DI TRANSIZIONE:
```{r}
#Probabilità di transizione di lì a :
pt1_PreMi <- probtrans(msf1_PreMi, predt = 0, method = "aalen")

pt1_Mi <- probtrans(msf1_Mi, predt = 0, method = "aalen")

pt1_PostMi.1 <- probtrans(msf1_PostMi.1, predt = 0, method = "aalen")

pt1_PostMi.2 <- probtrans(msf1_PostMi.2, predt = 0, method = "aalen")


statecols <- c("#C3EEBF", "#FBDD88", "#f78464", "#E05265")
ord <- c(1,2,3,4)
#plot: 
p1<-plot(pt1_PreMi, ord = ord, from=1, use.ggplot = TRUE, xlim = c(0,30))
p2<-plot(pt1_PreMi, ord = ord, from=2, use.ggplot = TRUE, xlim = c(0,30))
p3<-plot(pt1_PreMi, ord = ord, from=3, use.ggplot = TRUE, xlim = c(0,30))
p4<-plot(pt1_PreMi, ord = ord, from=4, use.ggplot = TRUE, xlim = c(0,30))
p5<-plot(pt1_Mi, ord = ord, from=1, use.ggplot = TRUE, xlim = c(0,30))
p6<-plot(pt1_Mi, ord = ord, from=2, use.ggplot = TRUE, xlim = c(0,30))
p7<-plot(pt1_Mi, ord = ord, from=3, use.ggplot = TRUE, xlim = c(0,30))
p8<-plot(pt1_Mi, ord = ord, from=4, use.ggplot = TRUE, xlim = c(0,30))
p9<-plot(pt1_PostMi.1, ord = ord, from=1, use.ggplot = TRUE, xlim = c(0,30))
p10<-plot(pt1_PostMi.1, ord = ord, from=2, use.ggplot = TRUE, xlim = c(0,30))
p11<-plot(pt1_PostMi.1, ord = ord, from=3, use.ggplot = TRUE, xlim = c(0,30))
p12<-plot(pt1_PostMi.1, ord = ord, from=4, use.ggplot = TRUE, xlim = c(0,30))
p13<-plot(pt1_PostMi.2, ord = ord, from=1, use.ggplot = TRUE, xlim = c(0,30))
p14<-plot(pt1_PostMi.2, ord = ord, from=2, use.ggplot = TRUE, xlim = c(0,30))
p15<-plot(pt1_PostMi.2, ord = ord, from=3, use.ggplot = TRUE, xlim = c(0,30))
p16<-plot(pt1_PostMi.2, ord = ord, from=4, use.ggplot = TRUE, xlim = c(0,30))


grid.arrange(p1 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From OnTime", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p2 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From Delay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p3 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p4 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From OnTime", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p5 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From Delay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p6 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p7 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From OnTime", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p8 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From Delay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p9 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p10 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From OnTime", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p11 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From Delay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p12 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             p13 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p14 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From OnTime", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p15 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From Delay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             p16 + scale_fill_manual(values = statecols) +
               theme_minimal() + 
               labs(title = "From SevereDelay", 
                    x = "Time (Minutes)", y = "Transition Probability") +
               guides(fill = guide_legend(title = "States")),
             
             nrow= 4, ncol = 4)  # Questo imposta 2 colonne
```


AIC del modello:
```{r}
AIC(c1_PreMi)
AIC(c1_Mi)
AIC(c1_PostMi.1)
AIC(c1_PostMi.2)
```

ELOS: Expected Lenght of Stay
Dall'help di R: Given a "probtrans" object, ELOS calculates the (restricted) expected length of stay in each of the states of the multi-state model.
ELOS(pt, tau)
The object pt needs to be a "probtrans" object, obtained with forward prediction. The restriction to tau is there because, as in ordinary survival analysis, the probability of being in a state can be positive until infinity, resulting in infinite values. The (restricted, until tau) expected length of stay in state h, given in state g at time s, is given by the integral from s to tau of P_gh(s,t).
```{r}
# pt1_PreMi <- probtrans(msf1_PreMi, predt = 0, method = "aalen")
# pt1_Mi <- probtrans(msf1_Mi, predt = 0, method = "aalen")
# pt1_PostMi.1 <- probtrans(msf1_PostMi.1, predt = 0, method = "aalen")
# pt1_PostMi.2 <- probtrans(msf1_PostMi.2, predt = 0, method = "aalen")

ELOS(pt1_PreMi)
ELOS(pt1_Mi)
ELOS(pt1_PostMi.1)
ELOS(pt1_PostMi.2)
```





